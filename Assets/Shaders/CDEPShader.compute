#pragma kernel CDEP

float3 camera_position;
float camera_ipd;
float camera_focal_dist;
float z_max;
float depth_hint;

Texture2D<float4> image : register(t0);
Texture2D<float4> depths : register(t1);
RWTexture2D<uint> out_rgbd : register(u0);

#define M_PI 3.1415926535897932384626433832795
#define EPSILON 0.000001

float fmod(float num, float div) {
    return num - div * floor(num / div);
}

uint packRgb776d12(float3 rgb, float depth) {
    uint r7 = uint(rgb.r * 127.0);
    uint g7 = uint(rgb.g * 127.0);
    uint b6 = uint(rgb.b * 63.0);
    uint d12 = uint(depth * 4095.0);
    return ((d12 & 0xFFF) << 20) | ((b6 & 0x3F) << 14) | ((g7 & 0x7F) << 7) | (r7 & 0x7F);
}

[numthreads(8, 8, 1)]
void CDEP(uint3 global_id : SV_DispatchThreadID) {
    uint width;
    uint height;
    image.GetDimensions(width, height);
    uint2 dims = uint2(width, height);
    if (global_id.x < dims.x && global_id.y < dims.y) {
        // Calculate projected point position (relative to original projection sphere center)
        float norm_x = (float(global_id.x) + 0.5) / float(dims.x);
        float norm_y = (float(global_id.y) + 0.5) / float(dims.y);
        float in_azimuth = 2.0 * M_PI * (1.0 - norm_x);
        float in_inclination = M_PI * norm_y;
        float in_depth = depths[global_id.xy].r;
        float3 pt = float3(in_depth * cos(in_azimuth) * sin(in_inclination),
                            in_depth * sin(in_azimuth) * sin(in_inclination),
                            in_depth * cos(in_inclination));
        
        // Backproject to new ODS projection sphere
        // 1) calculate azimuth/inclination to center of projection sphere
        float3 camera_spherical = camera_position.zxy;
        float3 vertex_direction = pt - camera_spherical;
        float magnitude = length(vertex_direction);
        float center_azimuth = (abs(vertex_direction.x) < EPSILON && abs(vertex_direction.y) < EPSILON) ? 
                       (1.0 - 0.5 * sign(vertex_direction.z)) * M_PI : 
                       atan2(vertex_direction.y, vertex_direction.x);
        float center_inclination = acos(vertex_direction.z / magnitude);

        // 2) calculate stereo camera location
        float camera_radius = 0.5 * camera_ipd * cos(center_inclination - (M_PI / 2.0));
        float camera_azimuth_l = center_azimuth + acos(camera_radius / magnitude); // left:  +
        float camera_azimuth_r = center_azimuth - acos(camera_radius / magnitude); // right: -
        float3 camera_pt_l = float3(camera_radius * cos(camera_azimuth_l),
                                    camera_radius * sin(camera_azimuth_l),
                                    0.0);
        float3 camera_pt_r = float3(camera_radius * cos(camera_azimuth_r),
                                    camera_radius * sin(camera_azimuth_r),
                                    0.0);

        // 3) project point onto projection sphere
        float proj_sphere_dist = sqrt(camera_focal_dist * camera_focal_dist - camera_radius * camera_radius);
        float3 camera_to_pt_l = vertex_direction - camera_pt_l;
        float camera_distance_l = length(camera_to_pt_l);
        float3 camera_ray_l = camera_to_pt_l / camera_distance_l;
        float3 proj_sphere_pt_l = camera_pt_l + proj_sphere_dist * camera_ray_l;
        float3 camera_to_pt_r = vertex_direction - camera_pt_r;
        float camera_distance_r = length(camera_to_pt_r);
        float3 camera_ray_r = camera_to_pt_r / camera_distance_r;
        float3 proj_sphere_pt_r = camera_pt_r + proj_sphere_dist * camera_ray_r;

        // 4) convert projected point to spherical coords
        float out_azimuth_l = (abs(proj_sphere_pt_l.x) < EPSILON && abs(proj_sphere_pt_l.y) < EPSILON) ? 
                            (1.0 - 0.5 * sign(proj_sphere_pt_l.z)) * M_PI : 
                            fmod(atan2(proj_sphere_pt_l.y, proj_sphere_pt_l.x), (2.0 * M_PI ));
        float out_inclination_l = acos(proj_sphere_pt_l.z / camera_focal_dist);
        float out_azimuth_r = (abs(proj_sphere_pt_r.x) < EPSILON && abs(proj_sphere_pt_r.y) < EPSILON) ? 
                            (1.0 - 0.5 * sign(proj_sphere_pt_r.z)) * M_PI : 
                            fmod(atan2(proj_sphere_pt_r.y, proj_sphere_pt_r.x), (2.0 * M_PI ));
        float out_inclination_r = acos(proj_sphere_pt_r.z / camera_focal_dist);

        // Write M_PI xel and depth to output textures
        uint out_x_l = uint(float(dims.x) * ((2.0 * M_PI) - out_azimuth_l) / (2.0 * M_PI));
        uint out_y_l = uint(float(dims.y) * (out_inclination_l / M_PI));
        uint out_x_r = uint(float(dims.x) * ((2.0 * M_PI) - out_azimuth_r) / (2.0 * M_PI));
        uint out_y_r = uint(float(dims.y) * (out_inclination_r / M_PI)) + dims.y;

        float4 color = image[global_id.xy];
        
        float dist_norm_l = (camera_distance_l + depth_hint) / z_max;
        uint rgbd_l = packRgb776d12(color.rgb, dist_norm_l);
        float dist_norm_r = (camera_distance_r + depth_hint) / z_max;
        uint rgbd_r = packRgb776d12(color.rgb, dist_norm_r);

        // multiple M_PI xels
        float size_ratio_l = max(round(in_depth / camera_distance_l), 1.0);
        int px_start_l = int(floor(0.5 * size_ratio_l));
        int px_end_l = int(ceil(0.5 * size_ratio_l));
        for (int j = -px_start_l; j < px_end_l; j++) {
            int f_y = int(out_y_l) + j;
            if (f_y >= 0 && f_y < int(dims.y)) {
                for (int i = -px_start_l; i <= px_end_l; i++) {
                    int f_x = int(out_x_l) + i;
                    if (f_x >= 0 && f_x < int(dims.x)) {
                        uint2 pix_idx_l = uint2(uint(f_x), (f_y) * dims.x);
                        InterlockedMin(out_rgbd[pix_idx_l], rgbd_l);
                    }
                }
            }
        }

        // multiple M_PI xels
        float size_ratio_r = max(round(in_depth / camera_distance_r), 1.0);
        int px_start_r = int(floor(0.5 * size_ratio_r));
        int px_end_r = int(ceil(0.5 * size_ratio_r));
        for (int j = -px_start_r; j < px_end_r; j++) {
            int f_y = int(out_y_r) + j;
            if (f_y >= int(dims.y) && f_y < 2 * int(dims.y)) {
                for (int i = -px_start_r; i <= px_end_r; i++) {
                    int f_x = int(out_x_r) + i;
                    if (f_x >= 0 && f_x < int(dims.x)) {
                        uint2 pix_idx_r = uint2(uint(f_x), (f_y) * dims.x);
                        InterlockedMin(out_rgbd[pix_idx_r], rgbd_r);
                    }
                }
            }
        }
    }
    
}
